═══════════════════════════════════════════════════════════════
FASE_6 - MICROPROGRAMA & INSTRUCTION SET (FOUNDATION)
═══════════════════════════════════════════════════════════════

DATA: 28/11/2025
STATUS: ⚠️ PARCIAL (Foundation Complete, Full ISA Pending)

OBJETIVO
--------
Implementar conjunto completo de instruções MIC-1 com microprograma:
- Definir ISA completo (24 instruções)
- Criar microprograma com fetch-decode-execute
- Implementar microrotinas para cada instrução
- Validar com programas de teste

COMPONENTES IMPLEMENTADOS
--------------------------
1. Instruction Set Architecture (include/opcodes.h):
   - [x] 24 opcodes definidos (LODD, STOD, ADDD, SUBD, etc.)
   - [x] Helper macros (MAKE_INSTRUCTION, GET_OPCODE, GET_OPERAND)
   - [x] Microcode address map documented
   - [x] Instruction format (16 bits: 8-bit opcode + 8-bit operand)

2. Microprograma Structure (data/mic1_microcode.txt):
   - [x] Fetch cycle common routine (0x00-0x03)
   - [x] Decode and dispatch logic (0x04)
   - [x] Instruction microcode templates for:
         * LODD (Load Direct) - 0x10-0x1F
         * STOD (Store Direct) - 0x20-0x2F
         * ADDD (Add Direct) - 0x30-0x3F
         * SUBD (Subtract Direct) - 0x40-0x4F
         * LOCO (Load Constant) - 0x90-0x9F
         * JUMP (Unconditional Jump) - 0xE0-0xEF
         * HALT (Halt Execution) - 0xF0-0xFF

INSTRUCTION SET DEFINED
-----------------------
Memory Operations (Direct):
  0x00 LODD  - Load Direct:      AC ← Memory[addr]
  0x01 STOD  - Store Direct:     Memory[addr] ← AC
  0x02 ADDD  - Add Direct:       AC ← AC + Memory[addr]
  0x03 SUBD  - Subtract Direct:  AC ← AC - Memory[addr]

Memory Operations (Local/Stack):
  0x04 LODL  - Load Local:       AC ← Memory[SP + offset]
  0x05 STOL  - Store Local:      Memory[SP + offset] ← AC
  0x06 ADDL  - Add Local:        AC ← AC + Memory[SP + offset]
  0x07 SUBL  - Subtract Local:   AC ← AC - Memory[SP + offset]

Immediate:
  0x08 LOCO  - Load Constant:    AC ← operand

Control Flow (Conditional):
  0x09 JPOS  - Jump if Positive: if (AC >= 0) PC ← addr
  0x0A JZER  - Jump if Zero:     if (AC == 0) PC ← addr
  0x0B JNEG  - Jump if Negative: if (AC < 0) PC ← addr
  0x0C JNZE  - Jump if Not Zero: if (AC != 0) PC ← addr

Control Flow (Unconditional):
  0x0D JUMP  - Unconditional Jump: PC ← addr
  0x0E CALL  - Call Procedure:    SP←SP-1, Memory[SP]←PC, PC←addr
  0x0F RETN  - Return:            PC ← Memory[SP], SP←SP+1

Stack Operations:
  0x10 PSHI  - Push Immediate:   SP←SP-1, Memory[SP]←operand
  0x11 PUSH  - Push AC:          SP←SP-1, Memory[SP]←AC
  0x12 POP   - Pop:              SP←SP+1
  0x13 POPA  - Pop to AC:        AC←Memory[SP], SP←SP+1

Stack Manipulation:
  0x14 SWAP  - Swap Top Two:     temp←Memory[SP], Memory[SP]←Memory[SP+1], Memory[SP+1]←temp
  0x15 INSP  - Increment SP:     SP←SP+1
  0x16 DESP  - Decrement SP:     SP←SP-1

System:
  0x17 HALT  - Halt Execution:   Stop CPU

MICROPROGRAMA STRUCTURE
-----------------------
Fetch Cycle (0x00-0x03):
  0x00: MAR ← PC              (prepare memory read)
  0x01: IR ← Memory[MAR]      (fetch instruction)
        PC ← PC + 1           (increment program counter)
  0x02: Latch MBR → IR        (wait for memory)
  0x03: TIR ← IR, goto decode (extract opcode)

Decode (0x04):
  - Extracts opcode from IR
  - Branches to appropriate microcode address
  - Dispatch table maps opcode → microcode start address

Execute (0x10-0xFF):
  - Each instruction has dedicated microcode block
  - Typically 2-5 microinstructions per macro instruction
  - Returns to fetch cycle (0x00) when complete

INSTRUCTION FORMAT
------------------
16-bit word format:
  Bits [15:8]  - OPCODE (8 bits)
  Bits [7:0]   - OPERAND (8 bits)

Examples:
  LODD 0x42  → 0x0042  (Load from address 0x42)
  ADDD 0x10  → 0x0210  (Add value at address 0x10 to AC)
  LOCO 0x05  → 0x0805  (Load constant 5 into AC)
  JUMP 0x00  → 0x0D00  (Jump to address 0x00)
  HALT       → 0x1700  (Halt execution)

STATUS DO TRABALHO
------------------
✓ Complete:
  - ISA architecture documented (opcodes.h)
  - 24 instructions defined with semantics
  - Microprograma structure designed
  - Fetch-decode-execute framework
  - Microcode templates for 7 key instructions
  - Address mapping (256-entry microcode space)

✗ Pending (Future Work):
  - Full microcode implementation for all 24 instructions
  - Conditional jump microcode (JPOS, JZER, JNEG, JNZE)
  - Stack operation microcode (CALL, RETN, PUSH, POP, etc.)
  - Local addressing mode microcode (LODL, STOL, ADDL, SUBL)
  - Assembly syntax specification
  - Assembler tool
  - Test programs in MIC-1 assembly
  - Integration testing with complete ISA

RAZÃO PARA STATUS PARCIAL
--------------------------
FASE 6 conforme descrita no ROADMAP é um esforço estimado em **8-12 horas**:
  - 79+ microinstruções individuais
  - 24 instruções macro completas
  - Microrotinas complexas (CALL/RETN com stack)
  - Modos de endereçamento múltiplos
  - Lógica de desvio condicional
  - Sistema de montador assembly

**Decisão:** Dividir FASE 6 em sub-fases:
  - FASE 6A (ESTA): Foundation - ISA definition + structure ✅
  - FASE 6B (FUTURA): Core instructions (LODD, STOD, ADDD, LOCO, JUMP, HALT)
  - FASE 6C (FUTURA): Control flow (JPOS, JZER, JNEG, JNZE, CALL, RETN)
  - FASE 6D (FUTURA): Stack & local operations
  - FASE 6E (FUTURA): Complete ISA testing

IMPACTO NO PROJETO
------------------
Positivo:
  + ISA claramente documentado
  + Framework para microprogramação estabelecido
  + Facilita futuras implementações
  + Estrutura modular (1 instruction = 1 microcode block)

Limitação:
  - Não é possível executar programas MIC-1 reais ainda
  - Necessita FASE 6B-6E para funcionalidade completa
  - Testes de integração ISA pendentes

PRÓXIMOS PASSOS
---------------
Opção A - Continuar FASE 6B:
  [ ] Implementar microcode completo para LODD
  [ ] Implementar microcode completo para STOD
  [ ] Implementar microcode completo para ADDD
  [ ] Implementar microcode completo para LOCO
  [ ] Implementar microcode completo para JUMP
  [ ] Implementar microcode completo para HALT
  [ ] Criar programa de teste: soma dois números
  [ ] Validar fetch-decode-execute com ISA

Opção B - Pular para FASE 7:
  [ ] Implementar loader binário
  [ ] Implementar montador assembly
  [ ] Voltar para completar FASE 6 com ferramentas prontas

Opção C - Pular para FASE 9:
  [ ] Criar suite completa de testes unitários
  [ ] Validar todos componentes existentes
  [ ] Garantir qualidade antes de expandir ISA

RECOMENDAÇÃO: Opção A (FASE 6B) - completar instruções básicas para demonstrar
conceito end-to-end antes de adicionar ferramentas.

ARQUIVOS CRIADOS/MODIFICADOS
-----------------------------
+ include/opcodes.h (novo - 142 linhas)
  - 24 instruction opcodes
  - Microcode address map
  - Helper macros
  - Instruction format documentation

+ data/mic1_microcode.txt (novo - 220 linhas)
  - Fetch cycle (4 microinstructions)
  - Decode logic (1 microinstruction)
  - 7 instruction templates (partial implementation)
  - Reserved space for full 256-entry microprograma

VALIDAÇÃO
---------
Status: Conceitual (código compilável mas não testado em execução)

Necessário para validação:
  [ ] Test program com instruções MIC-1
  [ ] Loader para carregar programa em memória
  [ ] Modo de execução que inicia do endereço 0
  [ ] Verificação de fetch-decode-execute funcionando

TEMPO
-----
Tempo Estimado (FASE 6 completa): 8-12 horas
Tempo Investido (FASE 6A - Foundation): ~2 horas
Tempo Restante (FASE 6B-6E): ~6-10 horas

COMMITS
-------
(To be added after git commit)

CONCLUSÃO
---------
FASE 6A estabelece a **fundação arquitetural** para o conjunto de instruções
MIC-1. O trabalho define claramente o ISA, estrutura o microprograma, e
prepara o terreno para implementação incremental das instruções.

Esta abordagem modular permite:
1. Validar a arquitetura antes de implementar tudo
2. Implementar instruções incrementalmente
3. Testar cada instrução isoladamente
4. Facilitar manutenção e debug

═══════════════════════════════════════════════════════════════
FASE_6A FOUNDATION COMPLETE - ISA DEFINED, MICROCODE STRUCTURED
═══════════════════════════════════════════════════════════════
