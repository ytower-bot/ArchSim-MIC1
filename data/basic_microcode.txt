# ============================================================================
# COMPLETE IJVM MICROPROGRAM FOR MIC-1
# ============================================================================
# Implements all 23 IJVM instructions as per Tanenbaum specification
#
# INSTRUCTION FORMAT (16 bits):
#   [15:12] Opcode (4 bits)
#   [11:0]  Operand (12 bits for most, 8 bits for INSP/DESP)
#
# MICROINSTRUCTION FORMAT (32 bits):
#   Bit Layout: [ADDR(8)][A(4)][B(4)][C(4)][ENC][WR][RD][MAR][MBR][SH(2)][ALU(2)][COND(2)][AMUX]
#   [31:24] ADDR  - Next microinstruction address
#   [23:20] A     - Source register A
#   [19:16] B     - Source register B  
#   [15:12] C     - Destination register
#   [11]    ENC   - Enable register write
#   [10]    WR    - Write to memory
#   [9]     RD    - Read from memory
#   [8]     MAR   - Load MAR
#   [7]     MBR   - Load MBR
#   [6:5]   SH    - Shifter control (00=none, 01=right, 10=left)
#   [4:3]   ALU   - ALU operation (00=A+B, 01=A AND B, 10=A, 11=NOT A)
#   [2:1]   COND  - Branch condition (00=none, 01=if_N, 10=if_Z, 11=always)
#   [0]     AMUX  - A input mux (0=Latch_A, 1=MBR)
#
# REGISTERS:
#   0=PC, 1=AC, 2=IR, 3=TIR, 4=SP, 5=AMASK(0x0FFF), 6=SMASK(0x00FF)
#   7=R0(0), 8=R1(+1), 9=Rm1(-1), 10-15=Temp registers
# ============================================================================

# ----------------------------------------------------------------------------
# FETCH CYCLE (0x00-0x04)
# ----------------------------------------------------------------------------

# 0x00: MAR ← PC
00000001000000000000000100000000

# 0x01: RD=1, read instruction from memory
00000010000000000000001000000000

# 0x02: IR ← MBR
00000011011101110010100000000001

# 0x03: PC ← PC + 1
00000100000010000000100000000000

# 0x04: Jump to dispatch
00000101000000000000000000000110

# ----------------------------------------------------------------------------
# DISPATCH (0x05-0x13) - Extract opcode and jump to handler
# ----------------------------------------------------------------------------
# Strategy: Shift IR right 12 times to get opcode in bits[3:0]
# Then use computed jump based on opcode value

# 0x05: Temp(10) ← IR >> 1
00000110001001111010100000100110

# 0x06: Temp(10) ← Temp >> 1
00000111101001111010100000100110

# 0x07: Temp(10) ← Temp >> 1
00001000101001111010100000100110

# 0x08: Temp(10) ← Temp >> 1
00001001101001111010100000100110

# 0x09: Temp(10) ← Temp >> 1
00001010101001111010100000100110

# 0x0A: Temp(10) ← Temp >> 1
00001011101001111010100000100110

# 0x0B: Temp(10) ← Temp >> 1
00001100101001111010100000100110

# 0x0C: Temp(10) ← Temp >> 1
00001101101001111010100000100110

# 0x0D: Temp(10) ← Temp >> 1
00001110101001111010100000100110

# 0x0E: Temp(10) ← Temp >> 1
00001111101001111010100000100110

# 0x0F: Temp(10) ← Temp >> 1
00010000101001111010100000100110

# 0x10: Temp(10) ← Temp >> 1, MBR ← Temp (final shift, copy opcode to MBR)
00010001101001111010110010100110

# 0x11: Dispatch jump (ADDR=0xFF triggers dispatch mode, base=0x14)
11111111000000000000000000000110

# 0x12-0x13: Reserved
00000000000000000000000000000110
00000000000000000000000000000110

# ----------------------------------------------------------------------------
# LODD (0x14-0x17): AC ← Memory[addr] - Opcode 0x0
# ----------------------------------------------------------------------------

# 0x14: MAR ← IR AND AMASK
00010101100000000010101100010001

# 0x15: RD=1
00010110000000000000001000000000

# 0x16: AC ← MBR
00010111011101110001100000000001

# 0x17: Return to fetch
00000000000000000000000000000110

# ----------------------------------------------------------------------------
# STOD (0x18-0x1B): Memory[addr] ← AC - Opcode 0x1
# ----------------------------------------------------------------------------

# 0x18: MAR ← IR AND AMASK
00011001100000000010101100010001

# 0x19: MBR ← AC
00011010000100000001011100000000

# 0x1A: WR=1
00011011001000000000000000000000

# 0x1B: Return to fetch
00000000000000000000000000000110

# ----------------------------------------------------------------------------
# ADDD (0x1C-0x1F): AC ← AC + Memory[addr] - Opcode 0x2
# ----------------------------------------------------------------------------

# 0x1C: MAR ← IR AND AMASK
00011101100000000010101100010001

# 0x1D: RD=1
00011110000000000000001000000000

# 0x1E: AC ← AC + MBR
00011111000100010001100000000001

# 0x1F: Return to fetch
00000000000000000000000000000110

# ----------------------------------------------------------------------------
# SUBD (0x20-0x25): AC ← AC - Memory[addr] - Opcode 0x3
# ----------------------------------------------------------------------------

# 0x20: MAR ← IR AND AMASK
00100001100000000010101100010001

# 0x21: RD=1
00100010000000000000001000000000

# 0x22: Temp(11) ← NOT MBR
00100011011111100111011101100001

# 0x23: Temp(11) ← Temp + 1 (two's complement)
00100100000010000011100001100000

# 0x24: AC ← AC + Temp
00100101000100010001100000000000

# 0x25: Return to fetch
00000000000000000000000000000110

# 0x26-0x27: Padding
00000000000000000000000000000110
00000000000000000000000000000110

# ----------------------------------------------------------------------------
# JPOS (0x28-0x2B): if (AC ≥ 0) PC ← addr - Opcode 0x4
# ----------------------------------------------------------------------------

# 0x28: Test AC (sets N flag)
00101001000000000001011100000000

# 0x29: If N=0 (AC≥0), PC ← IR AND AMASK
00101010000100000010101100000001

# 0x2A: Return to fetch
00000000000000000000000000000110

# 0x2B: Padding
00000000000000000000000000000110

# ----------------------------------------------------------------------------
# JZER (0x2C-0x2F): if (AC = 0) PC ← addr - Opcode 0x5
# ----------------------------------------------------------------------------

# 0x2C: Test AC (sets Z flag)
00101101000000000001011100000000

# 0x2D: If Z=1, PC ← IR AND AMASK
01101110000100000010101100000001

# 0x2E: Return to fetch
00000000000000000000000000000110

# 0x2F: Padding
00000000000000000000000000000110

# ----------------------------------------------------------------------------
# JUMP (0x30-0x31): PC ← addr - Opcode 0x6
# ----------------------------------------------------------------------------

# 0x30: PC ← IR AND AMASK
00110001000100000010101100000001

# 0x31: Return to fetch
00000000000000000000000000000110

# 0x32-0x33: Padding
00000000000000000000000000000110
00000000000000000000000000000110

# ----------------------------------------------------------------------------
# LOCO (0x34-0x35): AC ← constant - Opcode 0x7
# ----------------------------------------------------------------------------

# 0x34: AC ← IR AND AMASK
00110101001001010001100000001000

# 0x35: Return to fetch
00000000000000000000000000000110

# 0x36-0x37: Padding
00000000000000000000000000000110
00000000000000000000000000000110

# ----------------------------------------------------------------------------
# LODL (0x38-0x3C): AC ← Memory[SP + offset] - Opcode 0x8
# ----------------------------------------------------------------------------

# 0x38: Temp(11) ← IR AND AMASK
00111001100000000110101101100001

# 0x39: MAR ← SP + Temp
00111010100000000011011001010001

# 0x3A: RD=1
00111011000000000000001000000000

# 0x3B: AC ← MBR
00111100011101110001100000000001

# 0x3C: Return to fetch
00000000000000000000000000000110

# 0x3D-0x3F: Padding
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110

# ----------------------------------------------------------------------------
# STOL (0x40-0x44): Memory[SP + offset] ← AC - Opcode 0x9
# ----------------------------------------------------------------------------

# 0x40: Temp(11) ← IR AND AMASK
01000001100000000110101101100001

# 0x41: MAR ← SP + Temp
01000010100000000011011001010001

# 0x42: MBR ← AC
01000011000100000001011100000000

# 0x43: WR=1
01000100001000000000000000000000

# 0x44: Return to fetch
00000000000000000000000000000110

# 0x45-0x47: Padding
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110

# ----------------------------------------------------------------------------
# ADDL (0x48-0x4C): AC ← AC + Memory[SP + offset] - Opcode 0xA
# ----------------------------------------------------------------------------

# 0x48: Temp(11) ← IR AND AMASK
01001001100000000110101101100001

# 0x49: MAR ← SP + Temp
01001010100000000011011001010001

# 0x4A: RD=1
01001011000000000000001000000000

# 0x4B: AC ← AC + MBR
01001100000100010001100000000001

# 0x4C: Return to fetch
00000000000000000000000000000110

# 0x4D-0x4F: Padding
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110

# ----------------------------------------------------------------------------
# SUBL (0x50-0x56): AC ← AC - Memory[SP + offset] - Opcode 0xB
# ----------------------------------------------------------------------------

# 0x50: Temp(11) ← IR AND AMASK
01010001100000000110101101100001

# 0x51: MAR ← SP + Temp
01010010100000000011011001010001

# 0x52: RD=1
01010011000000000000001000000000

# 0x53: Temp(12) ← NOT MBR
01010100011111100111011101110001

# 0x54: Temp(12) ← Temp + 1
01010101000010000011110001110000

# 0x55: AC ← AC + Temp
01010110000100010001100000000000

# 0x56: Return to fetch
00000000000000000000000000000110

# 0x57: Padding
00000000000000000000000000000110

# ----------------------------------------------------------------------------
# JNEG (0x58-0x5B): if (AC < 0) PC ← addr - Opcode 0xC
# ----------------------------------------------------------------------------

# 0x58: Test AC (sets N flag)
01011001000000000001011100000000

# 0x59: If N=1, PC ← IR AND AMASK
00111010000100000010101100000001

# 0x5A: Return to fetch
00000000000000000000000000000110

# 0x5B: Padding
00000000000000000000000000000110

# ----------------------------------------------------------------------------
# JNZE (0x5C-0x5F): if (AC ≠ 0) PC ← addr - Opcode 0xD
# ----------------------------------------------------------------------------

# 0x5C: Test AC (sets Z flag)
01011101000000000001011100000000

# 0x5D: If Z=0 (not zero), PC ← IR AND AMASK
00111110000100000010101100000001

# 0x5E: Return to fetch
00000000000000000000000000000110

# 0x5F: Padding
00000000000000000000000000000110

# ----------------------------------------------------------------------------
# CALL (0x60-0x66): SP--, Memory[SP] ← PC, PC ← addr - Opcode 0xE
# ----------------------------------------------------------------------------

# 0x60: SP ← SP - 1
01100001010010010100100000000000

# 0x61: MAR ← SP
01100010100000000000100001010001

# 0x62: MBR ← PC
01100011000100000000000100000000

# 0x63: WR=1
01100100001000000000000000000000

# 0x64: PC ← IR AND AMASK
01100101000100000010101100000001

# 0x65: Return to fetch
00000000000000000000000000000110

# 0x66-0x67: Padding
00000000000000000000000000000110
00000000000000000000000000000110

# ----------------------------------------------------------------------------
# SPECIAL INSTRUCTIONS (0x68+) - Opcode 0xF
# Handler for 0xF prefix instructions (PSHI, POPI, PUSH, POP, RETN, SWAP, INSP, DESP)
# ----------------------------------------------------------------------------

# 0x68: Extract sub-opcode from IR[11:8] into Temp(13)
# Shift right 8 times to isolate bits
01101001001001111101110100110110

# 0x69: Temp(13) ← Temp >> 1
01101010110101111101110100110110

# 0x6A: Temp(13) ← Temp >> 1
01101011110101111101110100110110

# 0x6B: Temp(13) ← Temp >> 1
01101100110101111101110100110110

# 0x6C: Temp(13) ← Temp >> 1
01101101110101111101110100110110

# 0x6D: Temp(13) ← Temp >> 1
01101110110101111101110100110110

# 0x6E: Temp(13) ← Temp >> 1
01101111110101111101110100110110

# 0x6F: Temp(13) ← Temp >> 1
01110000110101111101110100110110

# 0x70: Temp(13) → MBR (sub-opcode in bits[3:0], no shift - já temos 8 shifts)
01110001110100000000001010000000

# 0x71: Temp(13) → MBR, Jump to special dispatch tree (0xF0)
11110000110100000000001011000110

# 0x72-0x77: Padding
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110

# ----------------------------------------------------------------------------
# PSHI (0x78-0x7D): SP--, Memory[SP] ← Memory[AC] - Sub-opcode 0x0
# ----------------------------------------------------------------------------

# 0x78: MAR ← AC
01111001100000000000000101010001

# 0x79: RD=1
01111010000000000000001000000000

# 0x7A: SP ← SP - 1
01111011010010010100100000000000

# 0x7B: Temp(14) ← MBR
01111100011101110011100000000001

# 0x7C: MAR ← SP
01111101100000000000100001010001

# 0x7D: MBR ← Temp(14)
01111110000100000011101100000000

# 0x7E: WR=1
01111111001000000000000000000000

# 0x7F: Return to fetch
00000000000000000000000000000110

# ----------------------------------------------------------------------------
# POPI (0x80-0x86): Memory[AC] ← Memory[SP], SP++ - Sub-opcode 0x2
# ----------------------------------------------------------------------------

# 0x80: MAR ← SP
10000001100000000000100001010001

# 0x81: RD=1
10000010000000000000001000000000

# 0x82: Temp(14) ← MBR
10000011011101110011100000000001

# 0x83: SP ← SP + 1
10000100010010000100100000000000

# 0x84: MAR ← AC
10000101100000000000000101010001

# 0x85: MBR ← Temp(14)
10000110000100000011101100000000

# 0x86: WR=1
10000111001000000000000000000000

# 0x87: Return to fetch
00000000000000000000000000000110

# ----------------------------------------------------------------------------
# PUSH (0x88-0x8C): SP--, Memory[SP] ← AC - Sub-opcode 0x4
# ----------------------------------------------------------------------------

# 0x88: SP ← SP - 1
10001001010010010100100000000000

# 0x89: MAR ← SP
10001010100000000000100001010001

# 0x8A: MBR ← AC
10001011000100000001011100000000

# 0x8B: WR=1
10001100001000000000000000000000

# 0x8C: Return to fetch
00000000000000000000000000000110

# 0x8D-0x8F: Padding
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110

# ----------------------------------------------------------------------------
# POP (0x90-0x94): AC ← Memory[SP], SP++ - Sub-opcode 0x6
# ----------------------------------------------------------------------------

# 0x90: MAR ← SP
10010001100000000000100001010001

# 0x91: RD=1
10010010000000000000001000000000

# 0x92: AC ← MBR
10010011011101110001100000000001

# 0x93: SP ← SP + 1
10010100010010000100100000000000

# 0x94: Return to fetch
00000000000000000000000000000110

# 0x95-0x97: Padding
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110

# ----------------------------------------------------------------------------
# RETN (0x98-0x9C): PC ← Memory[SP], SP++ - Sub-opcode 0x8
# ----------------------------------------------------------------------------

# 0x98: MAR ← SP
10011001100000000000100001010001

# 0x99: RD=1
10011010000000000000001000000000

# 0x9A: PC ← MBR
10011011011101110000100000000001

# 0x9B: SP ← SP + 1
10011100010010000100100000000000

# 0x9C: Return to fetch
00000000000000000000000000000110

# 0x9D-0x9F: Padding
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110

# ----------------------------------------------------------------------------
# SWAP (0xA0-0xA4): tmp ← AC, AC ← SP, SP ← tmp - Sub-opcode 0xA
# ----------------------------------------------------------------------------

# 0xA0: Temp(14) ← AC
10100001000100000001011101110001

# 0xA1: AC ← SP
10100010000100010010000100000001

# 0xA2: SP ← Temp(14)
10100011000010000011100100000001

# 0xA3: Return to fetch
00000000000000000000000000000110

# 0xA4-0xA7: Padding
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110

# ----------------------------------------------------------------------------
# INSP (0xA8-0xAC): SP ← SP + byte - Sub-opcode 0xC
# ----------------------------------------------------------------------------

# 0xA8: Temp(14) ← IR AND SMASK (extract 8-bit constant)
10101001100000000011100101100001

# 0xA9: SP ← SP + Temp
10101010000000000001011100100001

# 0xAA: Return to fetch
00000000000000000000000000000110

# 0xAB-0xAF: Padding
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110

# ----------------------------------------------------------------------------
# DESP (0xB0-0xB6): SP ← SP - byte - Sub-opcode 0xE
# ----------------------------------------------------------------------------

# 0xB0: Temp(14) ← IR AND SMASK
10110001100000000011100101100001

# 0xB1: Temp(14) ← NOT Temp
10110010111111100011101101110001

# 0xB2: Temp(14) ← Temp + 1 (negate)
10110011000010000011110001110000

# 0xB3: SP ← SP + Temp (SP - byte)
10110100000000000001011100100001

# 0xB4: Return to fetch
00000000000000000000000000000110

# 0xB5-0xBF: Padding
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110

# ----------------------------------------------------------------------------
# DISPATCH DECISION TREE (0xC0-0xF0)
# Sequential tests for opcodes 0-15 (0xF)
# ----------------------------------------------------------------------------

# After shifting at 0x05-0x11, Temp(10) contains opcode (0-15) in bits[3:0]

# 0xC0: Test if opcode == 0 (LODD)
11000001010000000111101000010100

# 0xC1: Test if opcode - 1 == 0 (STOD)
11000010010000001001101000011000

# 0xC2: Create -2 in Temp(12)
11000011000011001001100101100000

# 0xC3: Test if opcode - 2 == 0 (ADDD)
11000100010000001100101000011100

# 0xC4: Temp(12) ← Temp(12) - 1 (now -3)
11000101000011001001110001100000

# 0xC5: Test if opcode - 3 == 0 (SUBD)
11000110010000001100101000100000

# 0xC6: Temp(12) ← Temp(12) - 1 (now -4)
11000111000011001001110001100000

# 0xC7: Test if opcode - 4 == 0 (JPOS)
11001000010000001100101000101000

# 0xC8: Temp(12) ← Temp(12) - 1 (now -5)
11001001000011001001110001100000

# 0xC9: Test if opcode - 5 == 0 (JZER)
11001010010000001100101000101100

# 0xCA: Temp(12) ← Temp(12) - 1 (now -6)
11001011000011001001110001100000

# 0xCB: Test if opcode - 6 == 0 (JUMP)
11001100010000001100101000110000

# 0xCC: Temp(12) ← Temp(12) - 1 (now -7)
11001101000011001001110001100000

# 0xCD: Test if opcode - 7 == 0 (LOCO)
11001110010000001100101000110100

# 0xCE: Temp(12) ← Temp(12) - 1 (now -8)
11001111000011001001110001100000

# 0xCF: Test if opcode - 8 == 0 (LODL)
11010000010000001100101000111000

# 0xD0: Temp(12) ← Temp(12) - 1 (now -9)
11010001000011001001110001100000

# 0xD1: Test if opcode - 9 == 0 (STOL)
11010010010000001100101001000000

# 0xD2: Temp(12) ← Temp(12) - 1 (now -10)
11010011000011001001110001100000

# 0xD3: Test if opcode - 10 == 0 (ADDL)
11010100010000001100101001001000

# 0xD4: Temp(12) ← Temp(12) - 1 (now -11)
11010101000011001001110001100000

# 0xD5: Test if opcode - 11 == 0 (SUBL)
11010110010000001100101001010000

# 0xD6: Temp(12) ← Temp(12) - 1 (now -12)
11010111000011001001110001100000

# 0xD7: Test if opcode - 12 == 0 (JNEG)
11011000010000001100101001011000

# 0xD8: Temp(12) ← Temp(12) - 1 (now -13)
11011001000011001001110001100000

# 0xD9: Test if opcode - 13 == 0 (JNZE)
11011010010000001100101001011100

# 0xDA: Temp(12) ← Temp(12) - 1 (now -14)
11011011000011001001110001100000

# 0xDB: Test if opcode - 14 == 0 (CALL)
11011100010000001100101001100000

# 0xDC: Otherwise must be 15 (0xF - special), jump to special handler
01101000000000000000000000000110

# 0xDD-0xEF: Padding/Reserved
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110
00000000000000000000000000000110

# ----------------------------------------------------------------------------
# SPECIAL DISPATCH (0xF0-0xFF)
# Dispatch for 0xF sub-opcodes based on Temp(13) value
# ----------------------------------------------------------------------------

# After extracting sub-opcode at 0x68-0x70, Temp(13) contains value 0-15

# 0xF0: Test if sub-opcode == 0 (PSHI)
11110001110100000111110100111010

# 0xF1: Skip 1, test if == 2 (POPI)
11110010000011001001110001100000

# 0xF2: Test if sub-opcode - 2 == 0
11110011110100001100110110000010

# 0xF3: Temp - 1
11110100000011001001110001100000

# 0xF4: Test if sub-opcode - 4 == 0 (PUSH)
11110101110100001100110110001010

# 0xF5: Temp - 1
11110110000011001001110001100000

# 0xF6: Test if sub-opcode - 6 == 0 (POP)
11110111010000001100110110010000

# 0xF7: Temp - 1
11111000000011001001110001100000

# 0xF8: Test if sub-opcode - 8 == 0 (RETN)
11111001010000001100110110011000

# 0xF9: Temp - 1
11111010000011001001110001100000

# 0xFA: Test if sub-opcode - 10 == 0 (SWAP)
11111011010000001100110110100000

# 0xFB: Temp - 1
11111100000011001001110001100000

# 0xFC: Test if sub-opcode - 12 == 0 (INSP)
11111101010000001100110110101000

# 0xFD: Otherwise must be 14 (DESP)
10110000000000000000000000000110

# 0xFE-0xFF: Reserved
00000000000000000000000000000110
