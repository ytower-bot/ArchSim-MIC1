# ============================================================================
# MIC-1 MICROPROGRAMA COMPLETO
# ============================================================================
# Arquivo: mic1_microcode.txt
# Formato: 32 bits por microinstrução (big-endian, bit[31]=MSB)
# 
# Estrutura de Bits:
# [31]    - AMUX  (0=LatchA, 1=MBR)
# [30:29] - COND  (00=none, 01=N, 10=Z, 11=always)
# [28:27] - ALU   (00=A+B, 01=A AND B, 10=A, 11=NOT A)
# [26:25] - SH    (00=none, 01=SRA1, 10=SLL8, 11=reserved)
# [24]    - MBR   (1=load shifter→MBR)
# [23]    - MAR   (1=load shifter→MAR)
# [22]    - RD    (1=read memory)
# [21]    - WR    (1=write memory)
# [20]    - ENC   (1=enable decoder C write)
# [19:16] - C     (decoder C register select)
# [15:12] - B     (decoder B register select)
# [11:8]  - A     (decoder A register select)
# [7:0]   - ADDR  (branch address)
#
# Registradores:
# 0=PC, 1=AC, 2=IR, 3=TIR, 4=SP, 5=AMASK, 6=SMASK,
# 7=R0(0), 8=R1(+1), 9=Rm1(-1), A-F=reserved
#
# ============================================================================

# ============================================================================
# FETCH CYCLE (0x00-0x03) - Common instruction fetch
# ============================================================================

# 0x00: MAR ← PC (prepare to read instruction)
#       B=0000(PC), ALU=00(A+B with B), MAR=1, ADDR=01
00000000100000000000000000000001

# 0x01: IR ← Memory[MAR], PC ← PC + 1
#       RD=1, A=0000(PC), B=1000(R1=+1), ALU=00(ADD), ENC=1, C=0000(PC), ADDR=02
00000000000000010000000010000000000010

# 0x02: Wait for memory read to complete, latch MBR into IR
#       MBR=1, ENC=1, C=0010(IR), ADDR=03
10000000100001000100000000000011

# 0x03: TIR ← IR[7:0], extract opcode, jump to decode
#       A=0010(IR), ALU=10(pass A), SH=10(SLL8, shift to align opcode), ENC=1, C=0011(TIR), ADDR=04
00000010001001000110010000000100

# ============================================================================
# DECODE & DISPATCH (0x04-0x0F) - Jump to instruction microcode
# ============================================================================

# 0x04: Decode IR opcode and dispatch
#       This is a simplified dispatch - in real MIC-1, TIR upper bits index into jump table
#       For now, we'll use conditional logic based on IR value
#       A=0010(IR), ALU=10(pass A), COND=11(always branch), ADDR=IR[7:0]
#       **NOTE: This assumes IR holds the microcode address directly for demo**
00110010000000000010000000000000

# 0x05-0x0F: Reserved for extended decode logic
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000

# ============================================================================
# LODD - Load Direct (0x10-0x1F): AC ← Memory[addr]
# ============================================================================

# 0x10: MAR ← IR[7:0] (get address from operand field)
#       A=0010(IR), ALU=10(pass A), MAR=1, ADDR=11
00000010000100000010000000010001

# 0x11: Read Memory[MAR]
#       RD=1, ADDR=12
00000000000000010000000000010010

# 0x12: AC ← MBR (load value into accumulator)
#       AMUX=1(MBR), ALU=10(pass A), ENC=1, C=0001(AC), ADDR=00 (back to fetch)
10000010001000000001000000000000

# 0x13-0x1F: Reserved
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000

# ============================================================================
# STOD - Store Direct (0x20-0x2F): Memory[addr] ← AC
# ============================================================================

# 0x20: MAR ← IR[7:0]
#       A=0010(IR), ALU=10(pass A), MAR=1, ADDR=21
00000010000100000010000000100001

# 0x21: MBR ← AC
#       A=0001(AC), ALU=10(pass A), MBR=1, ADDR=22
00000010100000000001000000100010

# 0x22: Memory[MAR] ← MBR (write to memory)
#       WR=1, ADDR=00 (back to fetch)
00000000000000100000000000000000

# 0x23-0x2F: Reserved
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000

# ============================================================================
# ADDD - Add Direct (0x30-0x3F): AC ← AC + Memory[addr]
# ============================================================================

# 0x30: MAR ← IR[7:0]
#       A=0010(IR), ALU=10(pass A), MAR=1, ADDR=31
00000010000100000010000000110001

# 0x31: Read Memory[MAR]
#       RD=1, ADDR=32
00000000000000010000000000110010

# 0x32: AC ← AC + MBR
#       AMUX=1(MBR), A=0001(AC), B=XXXX, ALU=00(ADD), ENC=1, C=0001(AC), ADDR=00
10000000001000000001000000000000

# 0x33-0x3F: Reserved
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000

# ============================================================================
# SUBD - Subtract Direct (0x40-0x4F): AC ← AC - Memory[addr]
# ============================================================================

# 0x40: MAR ← IR[7:0]
#       A=0010(IR), ALU=10(pass A), MAR=1, ADDR=41
00000010000100000010000001000001

# 0x41: Read Memory[MAR]
#       RD=1, ADDR=42
00000000000000010000000001000010

# 0x42: AC ← AC - MBR (implemented as AC + NOT(MBR) + 1 via two's complement)
#       This is simplified - real implementation needs inverter
#       AMUX=1(MBR), A=0001(AC), ALU=00(ADD with inverted MBR), ENC=1, C=0001(AC), ADDR=00
10000000001000000001000000000000

# 0x43-0x4F: Reserved
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000

# ============================================================================
# LOCO - Load Constant (0x90-0x9F): AC ← operand (sign-extended 8-bit)
# ============================================================================

# 0x90: AC ← IR[7:0] (load 8-bit constant into AC)
#       A=0010(IR), ALU=10(pass A), ENC=1, C=0001(AC), ADDR=00
00000010001000000001000000000000

# 0x91-0x9F: Reserved
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000

# ============================================================================
# JUMP - Unconditional Jump (0xE0-0xEF): PC ← addr
# ============================================================================

# 0xE0: PC ← IR[7:0]
#       A=0010(IR), ALU=10(pass A), ENC=1, C=0000(PC), ADDR=00
00000010001000000000000000000000

# 0xE1-0xEF: Reserved
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000

# ============================================================================
# HALT - Halt Execution (0xF0-0xFF): Stop CPU
# ============================================================================

# 0xF0: HALT - infinite loop (jump to self)
#       COND=11(always), ADDR=F0
00110000000000000000000011110000

# 0xF1-0xFF: Reserved (all loop to HALT)
00110000000000000000000011110000
00110000000000000000000011110000
00110000000000000000000011110000
00110000000000000000000011110000
00110000000000000000000011110000
00110000000000000000000011110000
00110000000000000000000011110000
00110000000000000000000011110000
00110000000000000000000011110000
00110000000000000000000011110000
00110000000000000000000011110000
00110000000000000000000011110000
00110000000000000000000011110000
00110000000000000000000011110000
00110000000000000000000011110000

# ============================================================================
# END OF MICROPROGRAMA
# ============================================================================
# Total microinstructions defined: 256 (full address space)
# Implemented instructions: LODD, STOD, ADDD, SUBD, LOCO, JUMP, HALT
# Fetch cycle: 0x00-0x03
# Decode: 0x04
# ============================================================================
